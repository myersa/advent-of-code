#!/usr/bin/env python3
# https://adventofcode.com/2025/day/4

import numpy as np


PAPER_ROLL = "@"
EMPTY = "."
MAX_ADJACENT_ROLLS = 3


def read_input():
  grid = []
  with open("input.txt") as fh:
    for line in fh:
      line = line.rstrip()
      grid.append(list(line))
  return np.array(grid)


def is_in_bounds(grid: np.array, row_id: int, col_id: int) -> bool:
  if row_id < 0 or col_id < 0:
    return False

  if row_id >= grid.shape[0] or col_id >= grid.shape[1]:
    return False

  return True


def neighbors(grid: np.array, row_id: int, col_id: int):
  for i in (-1, 0, 1):
    for j in (-1, 0, 1):
      if i == 0 and j == 0:
        continue

      if not is_in_bounds(grid, row_id + i, col_id + j):
        continue

      yield row_id + i, col_id + j


def can_access(grid: np.array, row_id: int, col_id: int) -> bool:
  adjecent_rolls = 0
  thbt = list(neighbors(grid, row_id, col_id))
  for other_row_id, other_col_id in thbt:
    if grid[other_row_id, other_col_id] == PAPER_ROLL:
      adjecent_rolls += 1

  return adjecent_rolls <= MAX_ADJACENT_ROLLS


def main():
  grid = read_input()
  n_removed = 0
  n_passes = 0
  while True:
    to_remove_coords = []
    for row_id in range(grid.shape[0]):
      for col_id in range(grid.shape[1]):
        if grid[row_id, col_id] == PAPER_ROLL and can_access(grid, row_id, col_id):
          to_remove_coords.append((row_id, col_id))

    if not to_remove_coords:
      break

    for row_id, col_id in to_remove_coords:
      grid[row_id, col_id] = EMPTY

    n_removed += len(to_remove_coords)
    n_passes += 1

    print(f"Pass {n_passes}: removed {len(to_remove_coords)} rolls of paper.")

  print(f"Removed {n_removed} rolls of paper total, in {n_passes} passes.")


if __name__=="__main__":
  main()