#!/usr/bin/env python3
# https://adventofcode.com/2025/day/7

from functools import cache
import numpy as np

EMITTER = "S"
SPLITTER = "^"
BEAM = "|"
EMPTY = "."


class Labs():
  def _read_input(self):
    grid = []
    with open("input.txt") as fh:
      for line in fh:
        line = line.rstrip()
        grid.append(list(line))
    return np.array(grid)

  @cache
  def _trace_beam(self, row_id: int, beam_col_id: int) -> int:
    n_timelines = 0

    if row_id < self.grid.shape[0]:
      if self.grid[row_id, beam_col_id] == SPLITTER:
        # New timeline
        n_timelines += 1
        n_timelines += self._trace_beam(row_id + 1, beam_col_id - 1)
        n_timelines += self._trace_beam(row_id + 1, beam_col_id + 1)
      else:
        n_timelines += self._trace_beam(row_id + 1, beam_col_id)

    return n_timelines

  def main(self):
    # Detect splits as before. This time:
    # - don't update the grid
    # - recurse for each split possibility (DFS)

    self.grid = self._read_input()

    # Find the emitter on the first line, at width/2
    emitter_col_id = self.grid.shape[1] // 2
    if self.grid[0, emitter_col_id] != EMITTER:
      raise ValueError(f"Emitter not found at expected location (0, {emitter_col_id}).")

    # Start recursion on 2nd with single beam under the emitter
    n_timelines = self._trace_beam(1, emitter_col_id) + 1

    print(f"There were {n_timelines} timelines.")


if __name__=="__main__":
  Labs().main()