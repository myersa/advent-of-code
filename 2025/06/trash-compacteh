#!/usr/bin/env python3
# https://adventofcode.com/2025/day/6

import numpy as np
import operator
import re


OPS = {
  "+": operator.add,
  "*": operator.mul,
}
RE_WHITESPACE = re.compile(r"\s+")


def part1() -> None:
  # Read input

  table = []
  with open("input.txt") as fh:
    for line in fh:
      entries = RE_WHITESPACE.split(line.strip())
      table.append(entries)

  operators = [OPS[op] for op in table[-1]]
  all_operands = np.array([[int(entry) for entry in row] for row in table[:-1]])

  n_operands, n_equations = all_operands.shape
  print(f"Input is {n_equations} equations of {n_operands} operands each.")

  # Do calculations

  result_sum = 0
  for eq_id in range(n_equations):
    op = operators[eq_id]
    operands = iter(all_operands[:, eq_id])
    result = next(operands)
    for operand in operands:
      result = op(result, operand)
    result_sum += result

  print(f"[Part 1] Sum of all results: {result_sum}")


def part2() -> None:
  """
  Part 2 is way more complicated (as usual!)

  Now the number of spaces between the numbers matters.
  Observation: the operators (last line) are always left-justified.
  To figure out where to split the equations, read the operators line first.
  """

  # Read input

  with open("input.txt") as fh:
    # Remove newlines (but not other whitespace) from end.
    lines = [line.rstrip('\n') for line in fh.readlines()]
  operands_lines = lines[:-1]
  operators_line = lines[-1]

  operators = [OPS[op] for op in RE_WHITESPACE.split(operators_line.strip())]

  # 2-step parsing
  # Step 1: get operands "blocks" for each equation. Align by looking at operators.
  blocks = []
  def capture_block(left: int, right: int = None) -> None:
    block = []
    for operand_line in operands_lines:
      slice = operand_line[left:right-1] if right is not None else operand_line[left:]
      # Convert space to blank, for later joining
      block.append([c if c != ' ' else '' for c in slice])
    blocks.append(np.array(block))

  left = 0
  for right in range(1, len(operators_line)):
    if operators_line[right] != ' ':
      # Found the next operator. Capture block (combined slice of all operands lines) up to here.
      capture_block(left, right)
      left = right
  # Capture last block (from last operator to EOL)
  capture_block(left)

  # Step 2: get vertical operands. Most significant digit is on the top.
  operand_sets = []
  for block in blocks:
    operands = []
    for col_id in range(block.shape[1]):
      operand = int(''.join(block[:, col_id]))
      operands.append(operand)
    operand_sets.append(operands)
  
  # Perform calculations!

  result_sum = 0
  for operands, operator in zip(operand_sets, operators):
    operands = iter(operands)
    result = next(operands)
    for operand in operands:
      result = operator(result, operand)
    result_sum += result

  print(f"[Part 2] Sum of all results: {result_sum}")


if __name__=="__main__":
  part2()
